The concept of ServiceAccount is related to other aspect of security.
There are two type sof acount:
A userAccount and a serviceAccount    

UserAccount is used (for example) for a deployer to deploy an application                                      

A userAccount can be for an administrator accessing the cluster or for a developer to deploy applications.
A service account is an account used by an application that integrate with kubernetes cluster. For example a monitoring application like Prometheus or an automatic tools like Jenkis 
use a service account to deploy applications in a k8s cluster. 

In order to create a serviceAccount you can use an imperative command:
	- kubectl create serviceaccount <service-account-name>

When a service account is created, it creates always a token automatically.

This token is what the application needs to connect to the k8s cluster in order to be authenticated to the k8s API, the token is stored as a secret object.

So k8s -create-> ServiceAccount; token; secret and stores that token inside the secret object. The secret object is then linked to the service account.- 


	------------------------------------------------------------------
	|		Service Account					 |
	|	------------------------------------------		 |
	|	|		Secret			 |		 |
	|	|	--------------------------	 |		 |
	|	|	|	Token		 |	 |		 |
	|	|	--------------------------	 |		 |
	|	------------------------------------------		 |
	------------------------------------------------------------------



The secret name can be seen with the command:
	- kubectl describe serviceaccount <service-account-name>


The token can therefore be seen with the command

	- kubectl describe secret <secret-name>

Then the token can be used as a Bearer Authorization token.

So in the end you can create a serviceAccount, assign to him the role permissions you want and then use that token to authorize your application.

But what if your application is hosted on k8s, like prometheus for example. 
This whole procedure can make simple by automatically mounting the service token secret as a volume inside the pod hosting the application.

if you get all the service account 
	- kubectl get serviceaccount

You will see a default serviceaccount already exists. 
EACH NAMESPACE has it's own serviceaccount (the default one) and everytime a pod is created, that serviceaccount is automatically mounted as a volumne inside the container pod.

In order to see this you can check the pod information:
	- kubectl describe pod <pod-name>

=======
BEFORE
=======
By doing so you will see a volume has already mounted from the secret named default-token, you will see it both in Volumes and in Mounts.
If you type the command 

	- kubectl exec -it <pod-name> ls /var/run/secrets/kubernetes.io/serviceaccount 

You will see the secret mounted as 3 separated files, a file named token is the one that is used to authenticate the API
 
	- kubectl exec -it <pod-name> cat /var/run/secrets/kubernetes.io/serviceaccount/token

In order to see the token.

Now REMEMBER this default has really restricted permission it can do only basic queries.

If you want a pod to use a serviceAccount you created, instead of the one default just add it in the yml file


apiVersion: v1
kind: Pod
metadata:
	name: my-kubernetes-dashboard
spec:
	containers:
		- name: my-name
		  image: my-image
	serviceAccountName: serviceAccount


YOU CANNOT LINK A SERVICE ACCOUNT BY UPDATING THE POD, you have to delete and recreate the pod since there is volume to mount

You can even tell k8s not to mount the defatult serviceAccount:

apiVersion: v1
kind: Pod
metadata:
	name: my-kubernetes-dashboard
spec:
	containers:
		- name: my-name
		  image: my-image
	automountServiceAccountToken: false

======
NOW
======
Now let's discuess about the updates of serviceAccount which change the way on how serviceAccount works

If you decode with jwt.io the token, you will see that there is no expiration date, so jwt is valid as long as the serviceAccount exists. So in order to manage security and scalability
k8s introduce the TokenRequestAPI, the token generated by the TokenRequestAPI is Audience Bound, Time Bound, Object Bound.

Now when a new POD is created it no longer relies on ServiceAccount secretToken, instead a token with a specific lifetime is generated through the TokenRequestAPI, and that token is mount in a volume 
into that pod. 

By doing so now when you create a serviceAccount you no longer have the secret object inside and you have to create your token manually by typing:
	- kubectl create token <serviceAccountName>


	------------------------------------------------------------------
	|		Service Account					 |
	|								 |
	|						 		 |
	|		--------------------------	 		 |
	|		|	Token		 |	 		 |
	|		--------------------------	 		 |
	|								 |
	------------------------------------------------------------------

This time if you check the token you will see that there is one expiration date (generally one hour).

In order to create token from TokenRequestApi is enough to type:
	. kubectl create token


N.B. Despite the pictures which are created to make the hierarchy for serviceaccount | secret | token understandable, token is not a resource
So you can't type

	. kubectl get token 

In order to have a list of token